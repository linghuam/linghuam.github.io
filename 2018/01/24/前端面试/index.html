<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端面试题汇总 | 华仔的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="结合自己的面试经历和对网上一些面试题的收藏整理，汇总了一些前端面试常见的问题。个人觉得面试就是考试，平时不仅要会做事，还要善于总结和思考，把一些问题挖得再深些，该记忆的也要记忆，该熟练的也要熟练，这样才能在面试中游刃有余。 下面一些题目有些来自于大公司面试原题，想面试前端的不妨在面试前看看，说不定就遇到原题了。">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题汇总">
<meta property="og:url" content="http://linghuam.github.io/2018/01/24/前端面试/index.html">
<meta property="og:site_name" content="华仔的博客">
<meta property="og:description" content="结合自己的面试经历和对网上一些面试题的收藏整理，汇总了一些前端面试常见的问题。个人觉得面试就是考试，平时不仅要会做事，还要善于总结和思考，把一些问题挖得再深些，该记忆的也要记忆，该熟练的也要熟练，这样才能在面试中游刃有余。 下面一些题目有些来自于大公司面试原题，想面试前端的不妨在面试前看看，说不定就遇到原题了。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-01-27T12:29:46.578Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端面试题汇总">
<meta name="twitter:description" content="结合自己的面试经历和对网上一些面试题的收藏整理，汇总了一些前端面试常见的问题。个人觉得面试就是考试，平时不仅要会做事，还要善于总结和思考，把一些问题挖得再深些，该记忆的也要记忆，该熟练的也要熟练，这样才能在面试中游刃有余。 下面一些题目有些来自于大公司面试原题，想面试前端的不妨在面试前看看，说不定就遇到原题了。">
  
    <link rel="alternate" href="/atom.xml" title="华仔的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://linghuam.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="https://linghuam.github.io/project-gallery/dist/#/">项目展示</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">华仔的博客</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前端面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/前端面试/" class="article-date">
  <time datetime="2018-01-24T12:04:25.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/面试/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端面试题汇总
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>结合自己的面试经历和对网上一些面试题的收藏整理，汇总了一些前端面试常见的问题。<br>个人觉得面试就是考试，平时不仅要会做事，还要善于总结和思考，把一些问题挖得再深些，<br>该记忆的也要记忆，该熟练的也要熟练，这样才能在面试中游刃有余。</p>
<p>下面一些题目有些来自于大公司面试原题，想面试前端的不妨在面试前看看，说不定就遇到原题了。</p>
<a id="more"></a>
<h2 id="html-css"><a href="#html-css" class="headerlink" title="html + css"></a>html + css</h2><ul>
<li><p>css常用布局？</p>
<ul>
<li><p>流动模型</p>
<p>默认布局方式。典型特征是块状元素上下分布，行内元素左右分布。</p>
</li>
<li><p>浮动模型</p>
<p>float：none | left | right<br>clear: left | right | both | none<br>元素默认不能浮动，设置 float 使其浮动。<br>浮动元素的包含块是其最近的块级祖先元素，浮动元素会生成一个块级框，即使它是行内元素。<br>浮动元素的边界不能超出包含块。左右不能互超。<br>行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素‘之上’显示；<br>块框与一个浮动元素重叠时，其边框和背景在该浮动元素’之下’显示，而内容在浮动元素之上显示。<br>虽然从正常文档流中删除了，但还是会影响布局，其周围元素会环绕，并且外边距不能合并。</p>
</li>
<li><p>定位模型（层模型）</p>
<p>position: static | relative | absolute | fixed | sticky</p>
</li>
<li><p>flex</p>
<p>容器属性：</p>
<p>两轴：水平主轴 和 垂直交叉轴<br>flex-direction: 决定轴向。四种：水平左端、水平右端、垂直上沿、垂直下沿；<br>flex-wrap: 元素默认按一个轴排列，规定元素排不下时的方向。三种：不换行、换行第一行上、换行第一行下；<br>flex-flow: flex-direction 和 flex-wrap 简写形式<br>justify-content: 定义项目在水平轴对齐方向。 五种：左、右、居中、两端、均匀分布。<br>align-itmes: 定义项目在垂直轴对齐方向。五种：上、中、下、第一行文字基线、占满。<br>align-content: 定义了多根轴线的对齐方式。六种：交叉轴起点、交叉轴终点、交叉中中点、两端、均匀、占满。</p>
<p>元素属性：</p>
<p>order：定义排列顺序， 取值0，1，2…越小越靠前；<br>flex-grow: 定义元素放大比例，取值0，1，2…有剩余空间时，0表示不放大；<br>flex-shrink: 定义元素缩小比例，取值1，0, 2…空间不足时如何缩小；<br>flex-basis: 在分配多余空间之前，项目占据的主轴空间。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间；<br>flex: flex-grow、flex-shrink、flex-basis简写；<br>align-self: 定义与其他元素不一样的对齐方式，可覆盖 align-items属性。<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-examples.html</a></p>
</li>
<li><p>grid<br>flex是一个维度的，而grid是两个维度的网格式布局。</p>
</li>
<li><p>常用布局：三行布局（max-width自适应）；两栏布局（一边定宽，一边自适应）；三栏布局（圣杯、双飞翼）</p>
</li>
<li><p>圣杯与双飞翼区别：</p>
<ul>
<li>圣杯采用的是padding，而双飞翼采用的margin，解决了圣杯布局main的最小宽度不能小于左侧栏的缺点。</li>
<li>双飞翼布局不用设置相对布局，以及对应的left和right值。</li>
<li>通过引入相对布局，可以实现三栏布局的各种组合，例如对右侧栏设置position: relative; left: 190px; ,可以实现sub+extra+main的布局。</li>
</ul>
</li>
</ul>
</li>
<li><p>css盒模型？</p>
<p>定义：content + padding + border + margin</p>
<p>怪异盒模型：IE, 即： width = content + padding + border；<br>标准盒模型：即： width = content；</p>
<p>box-sizing: 设置 <code>box-sizing: content-box | border-box</code> 统一盒模型种类；</p>
<p>外边距合并： 普通文档流块级框的垂直外边距会合并，行内、浮动、绝对定位元素之间的外边距不合并。<br>设置 <code>*{padding:0;margin:0;}</code> 清除默认值；</p>
<p>margin越界：（第一个子元素的margin-top和最后一个子元素margin-bottom的值加在父元素上）<br>应该给父元素加前置内容。</p>
<p>盒模型画三角形：<code>{width:0;height:0;border:100px solid transparent;border-top:100px solid red;}</code></p>
</li>
<li><p>css 居中？</p>
<ul>
<li><p>水平居中</p>
<p>子元素为行内元素：<code>text-align:center</code>；</p>
<p>定宽块级元素：<code>margin:0 auto</code>；</p>
<p>多个块级元素：<code>display:inline-block;</code> 或 <code>display:flex;</code></p>
</li>
<li><p>垂直居中</p>
<p>行内元素(要求父元素定高)：<code>padding-top = padding-bottom</code><br>或 <code>line-height: ***</code><br>或 <code>display:table-cell;vertical-align:middle</code><br>或 <code>display:flex;justify-content:center;flex-direction:colum;</code></p>
<p>行内元素(父元素不定高)：设置伪元素的高等于父容器的高，然后添加 <code>vertical-align:middle</code></p>
<p>块级元素（已知高度，父元素相对定位）：<code>position:absolute;height:100px;top:50%;margin-top:-50px;</code></p>
<p>块级元素（未知高度，父元素相对定位）：<code>position:absolute;top:50%;transform:translateY(-50%);</code><br>或 <code>display:flex;flex-direction:colum;justify-content:center;</code></p>
</li>
<li><p>水平且垂直</p>
<p>宽高固定：<code>width:300px;height:100px;padding:20px;position:absolute;top:50%;left:50%;margin: -70px 0 0 -170px</code></p>
<p>高宽不固定：<code>position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);</code><br>或 <code>display:flex;justify-content:center;align-items:center;</code></p>
</li>
</ul>
</li>
<li><p>css 动画的理解？</p>
<p><strong>transition</strong>过渡是通过初始和结束两个状态的平滑过渡来实现简单动画。<br>包含四个属性：参与过渡的属性、持续时间、动画类型、延迟时间。</p>
<p><strong>animation</strong>通过关键帧来实现更为复杂的动画。<br>包含属性：动画名、持续时间、过渡类型、延迟时间、循环、反向。</p>
</li>
<li><p>css 动画 与 js 动画的比较？</p>
<p>webkit 内核浏览器的渲染线程分为主线程和 compositor 线程，js动画在主线程中完成，而<br>css动画在修改以下属性时‘仅触发composite，不触发layout、repaint’，这些属性有：transform、<br>opacity、perspective。</p>
<p>jQuery动画慢的原因：1、布局颠簸，复杂操作导致过多的重绘和重排；2、消耗内存，阻碍线程。</p>
<p>CSS3动画好的原因：1、优化DOM操作；2、开启3D加速，但会消耗内存。</p>
<p>总之：js动画灵活兼容性好，css动画则简单、某些情况下性能好，但缺乏灵活性和兼容性。</p>
<p>requestAnimationFrame：会把每一帧中的所有DOM操作集中起来，在一次重绘或重排中完成，并且时间间隔<br>紧随浏览器的刷新频率，每秒60帧。在隐藏或不可见元素中，requestAnimationFrame将不会进行重绘或重排。</p>
</li>
<li><p>浏览器渲染原理?</p>
<p>解析HTML构建DOM树、解析CSS构建Render树-&gt; Layout -&gt; Paint -&gt; Composite。<br>期间可引起重绘和重排。</p>
<p>减少重绘和重排方法：<br>不要频繁操作DOM，应该合并处理；position设为fixed或absolute；不要用table布局；使用css动画。</p>
</li>
<li><p>HTML页面加载和解析流程?</p>
<ol>
<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>
<li>浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；</li>
<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>
<li>浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>
<li>浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>
<li>浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它；</li>
<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>
<li>终于等到了＜/html＞的到来，浏览器泪流满面……</li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；</li>
<li>浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>
</ol>
</li>
<li><p>BFC?</p>
<p>css中盒模型布局的css渲染模式。布局方式属于常规文档流。<br>元素对其；外边距折叠；包含浮动；防止文字环绕；多列布局。</p>
</li>
<li><p>session、cookie、sessionStorage、localStorage等区别?</p>
<p>cookie存储在客户端，session存储在服务端，通过 session id 来识别客户端， session id存储在cookie中或url中。</p>
<p>当客户端第一次请求session对象时，服务端生成一个id并发送给客户端，客户端在下次请求时，再将这个id发送给服务端。</p>
<p>cookie安全性不好，session安全，但服务端压力大。</p>
</li>
<li><p>px/em/rem的区别?</p>
<p>都是相对长度。</p>
<p>px 相对屏幕分辨率而言；</p>
<p>em 值不固定，会继承父级元素的字体大小；</p>
<p>rem 相对的只是HTML根元素大小。</p>
</li>
<li><p>link 和 @import 区别？</p>
<p> link 是html标签，@import是css提供；</p>
<p> link 在页面加载时加载，@import引用的css会在页面加载完才开始加载；</p>
<p> link 优先级高于@import；</p>
<p> @import 兼容性不好 IE5以上；</p>
</li>
<li><p>css选择器？可以继承的属性？优先级算法？css3新增伪类元素？</p>
<p>选择器：id、class、标签、相邻（h1 + p）、子选择器(ul &gt; li)、后代、通配符、属性、伪类；</p>
<p>可继承：font-size font-family color ul li dl dd dt；</p>
<p>不可继承：border padding margin width height；</p>
<p>优先级： !important &gt; id &gt; 类 &gt; 其他； 内联样式大于css文件样式；文件后面样式大于前面样式；</p>
</li>
<li><p>doctype作用；严格模式与混杂模式？</p>
<p>声明在文档最前面，告知浏览器用什么文档类型和规范来解析这个文档；</p>
<p>严格模式是以浏览器支持的最高规格和标准来运行；</p>
<p>混杂模式是以向后兼容方式呈现；</p>
<p>doctype不存在或格式不正确会导致浏览器以混杂模式呈现。</p>
</li>
<li><p>行内元素？块级元素？空元素？</p>
<p>css规范规定，每个元素都有display属性，确定该元素类型，每个元素都有默认的display值，如div默认是block为块级元素，span默认inline为行内元素。</p>
<p>块级元素：独占一行；可以设置 width,height, margin, padding, border;</p>
<p>行内元素：和其他元素在同一行；不能设置宽高，可以设置 margin-left 、 margin-right，不能设置 margin-top,margin-bottom；</p>
<p>行内元素有：a b span img input select strong</p>
<p>块级元素有：div p ul ol li h1 h2 h3 h4 dl dt p</p>
<p>空元素（替换元素）：img input link meta  少见的：area base col …</p>
</li>
<li><p>iframe缺点</p>
<p>阻塞主页面的onload事件。</p>
<p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以影响页面并行加载。</p>
<p>如果需要使用iframe，最好用js动态给其加src属性。</p>
</li>
</ul>
<hr>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><ul>
<li><p>JavaScript数据类型分哪些？</p>
<p>Number、String、Boolean、Undefined、Null、Object</p>
</li>
</ul>
<ul>
<li><p>内置对象？</p>
<p>Date、Array、Math、Number、Boolean、String、RegExp、Function、Map、Set、WeakMap、WeakSet</p>
</li>
</ul>
<ul>
<li><p>typeof操作符结果？</p>
<p>undefined、boolean、string、number、object、function；</p>
<p>typeof null === ‘object’；</p>
<p>typeof Array === ‘object’;</p>
<p>typeof {} === ‘object’;</p>
<p>typeof Object === ‘function’；</p>
<p>typeof Function === ‘function’；</p>
</li>
</ul>
<ul>
<li><p>原型和原型链?</p>
<p>js中一切皆对象，分为普通对象和函数对象。</p>
<p>js中每个对象（函数、数组、数字…）都有 <code>__proto__</code> 属性，但只有函数对象才有 <code>prototype</code> 属性。</p>
<p>Person.prototype 就是原型对象。</p>
<p>js创建(new)对象时，将 <code>person.__proto__ = Person.prototype</code>。</p>
<p>原型和原型链是JS实现继承的一种模型。</p>
<p>原型链的形成是真正是靠<code>__proto__</code>而非 <code>prototype</code>。</p>
</li>
</ul>
<ul>
<li><p>闭包及常用的场景、作用域、单例模式?</p>
<p>局部变量不能共享和长久保存，全局变量会造成全局污染，而闭包避免了这两个问题。</p>
<p>js作用域是函数作用域。</p>
<p>闭包就是一个函数引用另外一个函数的变量。</p>
<p>当多个方法共享一个变量时，可用闭包实现；</p>
<p>在面向对象中，可用闭包实现私有变量；</p>
<p>在执行递归时；</p>
<p>因为变量被引用，所以不会被垃圾回收，闭包占用内存、消耗性能，使用要小心。</p>
</li>
</ul>
<ul>
<li><p>js异步的理解？</p>
<p>js是单线程的。</p>
<p>js通过事件循环和任务队列来执行异步操作的。</p>
<p>js只有一个线程，成为主线程，只有当主线程执行完成后才会执行异步线程。</p>
</li>
</ul>
<ul>
<li><p>JS继承的实现方式?</p>
<ul>
<li><p>原型链继承：将父类实例作为子类的原型</p>
<p>特点：实例是子类实例也是父类实例；父类新增原型属性时子类也能访问；易于实现。</p>
<p>缺点：无法实现多继承；来自原型对象的引用属性是所有实例共享的；创建子类时无法向父类构造函数传参。</p>
</li>
<li><p>构造继承：复制父类的实例属性给子类</p>
<p>特点：解决了子类实例共享父类引用属性的问题；创建子类实例是，可以向父类传参；可实现多继承。</p>
<p>缺点：只能继承父类的实例属性和方法，不能继承原型属性方法；每个子类都有父类实例副本，影响性能。</p>
</li>
<li><p>实例继承：为父类实例增加新特性，作为子类实例返回。</p>
<p>特点：new 和 直接调用都可返回实例。</p>
<p>缺点：实例是父类实例，不是子类；不支持多继承</p>
</li>
<li><p>拷贝继承:将父类的属性和方法一一拷贝到子类的原型对象中</p>
<p>特点：支持多继承</p>
<p>缺点：效率低；无法获取父类不可枚举属性。</p>
</li>
<li><p>组合继承: 调用父类构造，继承父类属性，将父类实例作为子类原型，实现复用。</p>
<p>特点：可以继承实例属性方法，也可继承原型属性方法；既是子类实例，也是父类实例；可传参。</p>
<p>缺点：调用了两次父类构造函数，生成了两份实例。</p>
</li>
<li><p>寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在两次调用父类构造的时候，不会构造两次，避免了组合继承的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Cat (name)&#123;</span><br><span class="line">   Animal.call(this);</span><br><span class="line">   this.name = name || &apos;tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line">(</span><br><span class="line">function ()&#123;</span><br><span class="line">  // 创建一个没有实例方法的类</span><br><span class="line">  var Super = function ()&#123;&#125;;</span><br><span class="line">  Super.prototype = Animal.prototype;</span><br><span class="line">  // 将实例作为子类的原型</span><br><span class="line">  Cat.prototype = new Super();</span><br><span class="line">&#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>JavaScript的节流和防抖?</p>
<p><strong>函数节流</strong>是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。</p>
<p><strong>函数防抖</strong>是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。</p>
<p>对于频繁的事件、频繁的ajax请求通过设置 setTimeout 来实现节流和防抖。</p>
</li>
</ul>
<ul>
<li><p>JavaScript的事件?</p>
<p>js是通过消息队列来处理事件的。</p>
<p>DOM2事件流：捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段。事件先从 document 往下流，在冒泡时触发目标事件，然后事件继续冒泡到跟节点。</p>
<p>事件对象：event.stopPropagation阻止事件传播；event.preventDefault阻止默认行为；event.target 事件源;<br>event.currentTarget 当前绑定事件的元素。</p>
<p>事件委托：将子元素的事件绑定到父元素上。优点：减少事件注册，节省内存；动态增加和修改子元素；</p>
</li>
</ul>
<ul>
<li><p>ajax请求方式?</p>
<ol>
<li><p>创建请求对象(考虑兼容性)，<code>xhr = new XMLHttpRequest()</code> 或 <code>xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></p>
</li>
<li><p>发送请求；</p>
<ul>
<li>get：<code>xhr.open(&#39;GET&#39;,&#39;url?params&#39;,isAsync); xhr.send()</code>;</li>
<li>post：<code>xhr.open(&#39;POST&#39;,&#39;url&#39;,isAsync);xhr.send(data)</code>;</li>
<li>在无法使用缓存、或更新服务器上的文件或数据、或传输大量数据时，用post。否则用get。</li>
</ul>
</li>
<li><p>获取服务器响应：xhr.responseText 和 xhr.responseXML;</p>
</li>
<li><p>监听响应状态：xhr.onreadystatechange 事件。</p>
<p>xhr.readyState 对象状态值:</p>
<ul>
<li>0（未初始化状态）对象已建立或已被abort()方法重置，尚未调用open方法。</li>
<li>1（初始化状态）服务器连接已建立，open()方法已经调用，但是send()方法未调用。请求还没有被发送。</li>
<li>2（发送数据）send()方法法以调用,HTTP请求已发送到Web服务器。未接收到响应。</li>
<li>3（数据传送中）所有响应头部都已经接收到。响应体开始接受但未完成。</li>
<li>4（完成加载）HTTP响应已经完全接收。</li>
</ul>
<p>xhr.status 状态:</p>
<ul>
<li>200：‘ok’</li>
<li>404: ‘未找到’</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>js判断数据类型的方法?<ul>
<li><code>typeof</code>: 返回字符串形式，可以判断<code>function</code>类型，但判断数组、对象、null时都返回<code>object</code>，通过 <code>Object.prototype.toString</code>来解决。</li>
<li><code>instanceof</code>: 判断已知对象类型， instanceof 后面必须为对象。适用于一些条件选择或分支。</li>
<li><code>constructor</code>: 在类继承时会出错。</li>
<li><code>prototype</code>: <code>Object.prototype.toString</code> 通用方法。</li>
<li><code>$.type()</code>: 返回null、undefined、object、对象或类名。</li>
</ul>
</li>
</ul>
<ul>
<li>this指向的问题?<ul>
<li>一般情况下，this在定义时是不能确定指向的，最终指向是执行时所在的对象。</li>
<li>默认情况下，没有调用对象，this指向window；严格模式下，this指向undefined。</li>
<li>new操作符、fn.call、fn.apply、fn.bind 可以改变this指向。</li>
<li>箭头函数，this指向是定义时所在的对象，而不是使用时所在的对象。</li>
</ul>
</li>
</ul>
<ul>
<li><p>new干了什么？</p>
<p>创建一个空对象，this变量引用该对象同时还继承了该函数的原型；</p>
<p>属性和方法被加入到this引用的对象中；</p>
<p>新创建的对象有this引用，并最后隐式返回this;</p>
</li>
</ul>
<ul>
<li><p>跨域。JSONP原理和实现。CORS设置?</p>
<p>同源策略（同协议、域名、端口号）限制了请求。</p>
<p>JSONP、Hash、postMessage、WebSocket、CORS、代理。</p>
</li>
</ul>
<ul>
<li><p>浅拷贝与深拷贝？</p>
<p>浅拷贝是改变引用，深拷贝递归进行，改变内存。</p>
<p>JSON.stringify 和 JSON.parse 实现。缺点是非json标准的无法拷贝，兼容性问题。<br>尾递归实现深拷贝的原理。</p>
<p>缺点：不能被文本化的东西被忽略；</p>
</li>
</ul>
<ul>
<li><p>数组去重?</p>
<p>ES6实现：<code>[...new Set([1,2,3,1,&#39;a&#39;,1,&#39;a&#39;])]</code></p>
<p>ES5实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">1</span>,<span class="string">'a'</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index === array.indexOf(ele)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象的方法?</p>
<p>对象字面量、new Object()、Object.create()</p>
</li>
</ul>
<ul>
<li><p>怎样添加、移除、移动、复制、创建和查找节点？</p>
<ul>
<li>创建新节点： createDocumentFragment() createElement() createTextNode()</li>
<li>添加、移除、替换、插入：appendChild() removeChild() replaceChild() insertBefore()</li>
<li>查找：querySelect() querySelectAll() getElementById() getElementsByName() getElementsByTagName()</li>
</ul>
</li>
<li><p>es6-promise?</p>
<p>用于处理js中的一些异步过程。</p>
<p>1.初始化一个Promise对象，构造函数中有’resolve’和‘reject’参数，分别在成功和失败时执行。</p>
<p>2.一个Promise有以下状态：</p>
<ul>
<li>pending:初始状态，既不是成功，也不是失败；</li>
<li>fulfilled:操作成功；</li>
<li>rejected:操作失败；</li>
</ul>
<p>3.Promise实例有then和catch方法。</p>
</li>
</ul>
<ul>
<li><p>es6-generator?</p>
<p>可以返回多次的函数。</p>
</li>
</ul>
<ul>
<li><p>es6-fetch?</p>
<p>fetch接收两个参数，URL和请求options；</p>
<p>返回promise对象，可以通过 then 和 catch 分别处理成功和失败；</p>
<p>与ajax比较：</p>
<ol>
<li>fetch不能停止；</li>
<li>默认不带cookie；需配置credentials：’inclue’；</li>
<li>服务器返回400、500 时并不会reject；</li>
<li>不能获取状态；</li>
<li>没有defer；</li>
</ol>
</li>
<li><p>JS模块化Commonjs,UMD,CMD规范的了解，以及ES6的模块化跟其他几种的区别，以及出现的意义？</p>
<ul>
<li>CommonJS：服务端加载，同步，Nodejs</li>
<li>AMD：前端加载，RequireJs，异步加载，预加载</li>
<li>CMD：前端加载，Seajs，懒加载</li>
<li>UMD：AMD 和 CommonJS的糅合，解决跨平台；运行时</li>
<li>ES6 Import、Export：通用；静态确定关系；</li>
</ul>
</li>
<li><p>函数柯里化？以及说一下JS的API有哪些应用到了函数柯里化的实现？</p>
<p>这个我就说了一下函数柯里化一些了解，以及在函数式编程的应用，最后说了一下JS中bind函数和数组的reduce方法用到了函数柯里化。</p>
</li>
</ul>
<hr>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul>
<li><p>http？<a href="https://www.jianshu.com/p/6aa2fda4d4a1" target="_blank" rel="noopener">详解</a></p>
<p>协议分层： http应用层 ——&gt; TCP传输层 ——&gt; IP网络层 ——&gt; 链路层（网络接口）——&gt; 物理层（网卡）</p>
<p>封装：发送端在层与层传输数据时，每经过一层必定会打上改成所属的首部信息；接收端在层与层传输数据<br>时，每经过一层会把对应的首部消去。</p>
<p>三次握手策略：</p>
</li>
</ul>
<ul>
<li><p>https？</p>
<p>加密处理防止窃听。可通过SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输协议）的组合使用，加密通信。与SSL组合使用的HTTP叫HTTPS。</p>
</li>
</ul>
<ul>
<li>从输入网址到看到页面的过程？</li>
</ul>
<ul>
<li>post、get区别？<ol>
<li>本质都是 TCP 连接，并无区别，只是贴上不同的标签，便于处理；</li>
<li>get 只产生一个 TCP 数据包， post 产生两个 TCP数据包；</li>
<li>get 在一次请求中将 header 和 data 发送给服务器，服务器返回 200；</li>
<li>post 先发送 header 再 发送 data；</li>
</ol>
</li>
</ul>
<ul>
<li><p>缓存？</p>
<ul>
<li>200 ok ：当浏览器没有缓存，或用户强制刷新，浏览器直接获取最新数据。</li>
<li>304：由 last-modified/etag 控制。先发送请求到服务器，如果没有变化，返回304。</li>
<li>200 from cache：由 expires/cache-control 控制。</li>
</ul>
<p>策略：<a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">详情</a></p>
<ul>
<li>Expires 缺点:绝对时间</li>
<li>Cache-Control 相对时间 max-age 控制缓存在时间</li>
<li>Last-Modified/If-Modified-Since</li>
<li>Etag/If-None-Match</li>
</ul>
</li>
</ul>
<ul>
<li><p>http常见状态码？</p>
<ul>
<li>2开头 （请求成功）表示成功处理了请求的状态代码。</li>
<li>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li>
<li>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</li>
<li>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</li>
</ul>
</li>
</ul>
<ul>
<li><p>前端优化一般都做哪些？</p>
<p><a href="https://www.zhihu.com/question/21658448" target="_blank" rel="noopener">详情地址</a></p>
</li>
</ul>
<ul>
<li><p>浏览器内核？常见兼容性问题？常用hack技巧？</p>
<p><a href="https://zhuanlan.zhihu.com/p/27447843" target="_blank" rel="noopener">详情</a></p>
<p>IE：Trident</p>
<p>Mozilla: Gecko</p>
<p>Goole: webkit</p>
<p>Opera: Presto</p>
<p>浏览器默认margin、padding不同。解决办法是加一个全局的。</p>
</li>
</ul>
<hr>
<h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p><a href="https://linghuam.github.io/2017/12/28/%E4%BA%86%E8%A7%A3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91/">了解移动端开发</a></p>
<hr>
<h2 id="vuejs、angularjs、reactjs"><a href="#vuejs、angularjs、reactjs" class="headerlink" title="vuejs、angularjs、reactjs"></a>vuejs、angularjs、reactjs</h2><ul>
<li><p>vue数据绑定原理？ <a href="https://segmentfault.com/a/1190000006599500" target="_blank" rel="noopener">详情</a></p>
<p>vue是通过<strong>数据劫持</strong>的方式来做数据绑定的，其中最核心的方法便是通过<code>Object.defineProperty()</code>来实现对属性的劫持，达到监听数据变动的目的。</p>
</li>
</ul>
<ul>
<li>Vue生命周期？<ol>
<li>beforeCrate: 实例刚被创建，data计算前。</li>
<li>created： 实例创建完成，属性已绑定，但DOM还未生成。data初始化，$el还不存在。</li>
<li>beforeMount：挂载前，完成 data 和 el 初始化。</li>
<li>mounted： 挂载后</li>
<li>beforeUpdate：更新前</li>
<li>updated：更新后</li>
<li>beforeDestory：销毁前</li>
<li>destoryed啊：销毁后</li>
</ol>
</li>
</ul>
<ul>
<li>Vue组件数据通信？<ol>
<li>父到子：props down； 子组件中 this.$parent</li>
<li>子到父：events up；this.$ref</li>
<li>兄弟组件：中专站， new Vue()</li>
<li>vuex</li>
</ol>
</li>
</ul>
<ul>
<li><p>vuex原理？</p>
<p><a href="https://tech.meituan.com/vuex-code-analysis.html" target="_blank" rel="noopener">详情</a></p>
</li>
</ul>
<ul>
<li><p>Vue脏检查？</p>
<p>在 angular中，他没有办法判断你的数据是否做了更改， 所以它设置了一些条件，当你触发了这些条件之后，它就执行一个检测来遍历所有的数据，对比你更改了地方，然后执行变化。这个检查很不科学。而且效率不高，有很多多余的地方，所以官方称为脏检查。</p>
<p>Vue.js 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步列队更新，所有的数据变化都是独立地触发，除非它们之间有明确的依赖关系。唯一需要做的优化是在 v-for 上使用 track-by。</p>
</li>
</ul>
<ul>
<li><p>MVC、MVVM了解么，数据双向绑定和单向绑定实现方式？</p>
<p>vue 和 angular 实现双向绑定，React 是单向数据流。</p>
<p>单向绑定的优点是相应的可以带来单向数据流，这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”。同时组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性。缺点则是代码量会相应的上升，数据的流转过程变长，从而出现很多类似的样板代码。同时由于对应用状态独立管理的严格要求(单一的全局store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。</p>
<p>基本上双向绑定的优缺点就是单向绑定的镜像了。优点是在表单交互较多的场景下，会简化大量业务无关的代码。缺点就是由于都是“暗箱操作”，我们无法追踪局部状态的变化(虽然大部分情况下我们并不关心)，潜在的行为太多也增加了出错时 debug 的难度。同时由于组件数据变化来源入口变得可能不止一个，新手玩家很容易将数据流转方向弄得紊乱，如果再缺乏一些“管制”手段，最后就很容易因为一处错误操作造成应用雪崩。</p>
</li>
</ul>
<ul>
<li><p>前端路由原理？</p>
<p><a href="https://segmentfault.com/a/1190000007238999" target="_blank" rel="noopener">详情</a><br>history API 和 Hash</p>
</li>
</ul>
<ul>
<li><p>说一下Vue实现双向数据绑定的原理，以及vue.js和react.js异同点，如果让你选框架，你怎么怎么权衡这两个框架，分析一下？</p>
<p>主要是发布订阅的设计模式，还有就是ES5的Object.defineProperty的getter和setter机制，然后顺便扯了一下Angular的脏检测</p>
</li>
</ul>
<hr>
<h2 id="webpack、sass、npm、babel、eslint、Git、Travis-ci"><a href="#webpack、sass、npm、babel、eslint、Git、Travis-ci" class="headerlink" title="webpack、sass、npm、babel、eslint、Git、Travis-ci"></a>webpack、sass、npm、babel、eslint、Git、Travis-ci</h2><p>《深入浅出webpack》 <a href="http://webpack.wuhaolin.cn/" target="_blank" rel="noopener">http://webpack.wuhaolin.cn/</a></p>
<ul>
<li>webpack入口、多入口、assetPath</li>
<li>webapck loader 原理及配置</li>
<li>打包性能优化</li>
<li>babel原理</li>
</ul>
<hr>
<h2 id="canvas、svg、css3、echarts、threejs"><a href="#canvas、svg、css3、echarts、threejs" class="headerlink" title="canvas、svg、css3、echarts、threejs"></a>canvas、svg、css3、echarts、threejs</h2><ul>
<li><p>canvas 与 svg 区别</p>
<p><a href="http://www.w3school.com.cn/html5/html_5_canvas_vs_svg.asp" target="_blank" rel="noopener">详情</a></p>
</li>
</ul>
<ul>
<li>屏幕坐标转化</li>
</ul>
<hr>
<h2 id="leaflet、mapbox、webGIS、"><a href="#leaflet、mapbox、webGIS、" class="headerlink" title="leaflet、mapbox、webGIS、"></a>leaflet、mapbox、webGIS、</h2><ul>
<li>切图原理</li>
<li>坐标转换</li>
</ul>
<hr>
<h2 id="nodejs、express、socket-io、python、mysql、sqllite、liunx…"><a href="#nodejs、express、socket-io、python、mysql、sqllite、liunx…" class="headerlink" title="nodejs、express、socket.io、python、mysql、sqllite、liunx…"></a>nodejs、express、socket.io、python、mysql、sqllite、liunx…</h2><p>node.js面试题大全－侧重后端应用与对Node核心的理解：<a href="https://www.cnblogs.com/meteorcn/p/node_mianshiti_interview_question.html" target="_blank" rel="noopener">https://www.cnblogs.com/meteorcn/p/node_mianshiti_interview_question.html</a></p>
<hr>
<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul>
<li>技术栈</li>
<li>要问的问题</li>
<li>说一下项目中觉得可以改进的地方以及做的很优秀的地方？</li>
<li>一个业务场景，面对产品不断迭代，以及需求的变动该怎么应对，具体技术方案实现。</li>
<li><p>XSS是什么，攻击原理，怎么预防。</p>
<p>跨站脚本攻击XSS(cross site scripting)，攻击类型主要有两种：反射型和存储型，简单说了一下如何防御：</p>
</li>
<li><p>CRSF:跨站请求伪造</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://linghuam.github.io/2018/01/24/前端面试/" data-id="cjd1rquad0019qxbxda7turgh" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =3
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2018/01/27/计算机图形学-圆生成算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          计算机图形学-圆生成算法
        
      </div>
    </a>
  
  
    <a href="/2018/01/12/直线生成算法-直线的Bresenham算法/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">直线生成算法-直线的Bresenham算法</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
           <div id="gitment_comments"></div>
    
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#html-css"><span class="toc-number">1.</span> <span class="toc-text">html + css</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js"><span class="toc-number">2.</span> <span class="toc-text">js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器"><span class="toc-number">3.</span> <span class="toc-text">浏览器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移动端"><span class="toc-number">4.</span> <span class="toc-text">移动端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuejs、angularjs、reactjs"><span class="toc-number">5.</span> <span class="toc-text">vuejs、angularjs、reactjs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack、sass、npm、babel、eslint、Git、Travis-ci"><span class="toc-number">6.</span> <span class="toc-text">webpack、sass、npm、babel、eslint、Git、Travis-ci</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canvas、svg、css3、echarts、threejs"><span class="toc-number">7.</span> <span class="toc-text">canvas、svg、css3、echarts、threejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leaflet、mapbox、webGIS、"><span class="toc-number">8.</span> <span class="toc-text">leaflet、mapbox、webGIS、</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodejs、express、socket-io、python、mysql、sqllite、liunx…"><span class="toc-number">9.</span> <span class="toc-text">nodejs、express、socket.io、python、mysql、sqllite、liunx…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other"><span class="toc-number">10.</span> <span class="toc-text">other</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 Linghuam&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;linghuam2016@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="https://linghuam.github.io/project-gallery/dist/#/" class="mobile-nav-link">项目展示</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> 
  <script>
  var gitment = new Gitment({
    // id: '页面 ID', // 可选。默认为 location.href
    owner: 'linghuam',
    repo: 'linghuam.github.io',
    oauth: {
    client_id: '17ad04af6a057fbb5072',
    client_secret: '5bb953d9587f8f1bde7c956bda62db16779dab4c',
    }
  })
  gitment.render(document.getElementById("gitment_comments"))
</script>


<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'] ],
          displayMath: [ ["$$","$$"] ], //段内公式选择$$
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>